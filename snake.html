<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Multi-Apple Snake — Single Page Game</title>
  <style>
    :root{
      --bg:#071022;
      --panel:#0f1724;
      --accent:#ffd166;
      --muted:#a6b4c2;
      --good:#4caf50;
      --bad:#ff6b6b;
    }
    html,body{height:100%;margin:0;font-family:Inter, ui-sans-serif, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial; background:radial-gradient(circle at 10% 10%, rgba(255,209,102,0.04), transparent), var(--bg); color:#eaf2ff;display:flex;align-items:center;justify-content:center}
    .wrap{width:100%;max-width:980px;padding:24px}
    header{display:flex;align-items:center;gap:18px;justify-content:space-between;margin-bottom:18px}
    h1{font-family:'Fredoka One', Arial, sans-serif;margin:0;font-size:24px;color:var(--accent)}
    .controls{display:flex;gap:10px;align-items:center}
    button{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.04);padding:8px 12px;border-radius:8px;color:inherit;cursor:pointer}
    .panel{display:grid;grid-template-columns:1fr 260px;gap:18px;align-items:start}
    .gamebox{background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));border-radius:12px;padding:12px;border:1px solid rgba(255,255,255,0.03)}
    canvas{background:#081026;border-radius:8px;display:block;margin:0 auto}
    .sidebar{background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.015));padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03)}
    .stat{display:flex;justify-content:space-between;padding:6px 0;font-weight:700}
    label{display:block;margin-top:10px;font-size:13px;color:var(--muted)}
    input[type=range]{width:100%}
    .hint{font-size:13px;color:var(--muted);margin-top:8px}
    footer{margin-top:12px;color:var(--muted);font-size:13px}
    @media (max-width:820px){.panel{grid-template-columns:1fr} .sidebar{order:2}}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Multi-Apple Snake</h1>
      <div class="controls">
        <button id="startBtn">Start</button>
        <button id="pauseBtn">Pause</button>
        <button id="resetBtn">Reset</button>
      </div>
    </header>

    <div class="panel">
      <div class="gamebox">
        <canvas id="game" width="640" height="640" aria-label="Snake game canvas"></canvas>
      </div>

      <aside class="sidebar">
        <div class="stat"><span>Score</span><span id="score">0</span></div>
        <div class="stat"><span>Length</span><span id="length">1</span></div>
        <div class="stat"><span>Apples on field</span><span id="applesCount">3</span></div>
        <label>Grid size: <strong id="gridLabel">32</strong></label>
        <input id="gridRange" type="range" min="16" max="64" value="32">
        <label>Base speed (moves/sec): <strong id="speedLabel">8</strong></label>
        <input id="speedRange" type="range" min="4" max="18" value="8">
        <label>Apple count</label>
        <input id="appleCount" type="range" min="1" max="8" value="3">
        <div class="hint">Controls: Arrow keys or WASD. On mobile, swipe to move. Eating apples grows snake and increases score.</div>
        <div style="margin-top:10px;font-size:13px;color:var(--muted)">This is a single-file HTML + JS snake. You can tweak grid, speed, and apples.</div>
      </aside>
    </div>

    <footer>Created for you — enjoy! (Refresh resets)</footer>
  </div>

  <script>
    // Basic single-file Snake with multiple apples
    (function(){
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');
      let grid = 32; // cells per row/col
      let cellSize = canvas.width / grid;

      // Game state
      let snake = [{x: Math.floor(grid/2), y: Math.floor(grid/2)}];
      let dir = {x:1,y:0};
      let nextDir = dir;
      let apples = [];
      let appleCount = 3;
      let score = 0;
      let running = false;
      let paused = false;
      let baseSpeed = 8; // moves per second
      let lastMoveTime = 0;
      let moveInterval = 1000 / baseSpeed;

      // UI
      const startBtn = document.getElementById('startBtn');
      const pauseBtn = document.getElementById('pauseBtn');
      const resetBtn = document.getElementById('resetBtn');
      const scoreEl = document.getElementById('score');
      const lenEl = document.getElementById('length');
      const applesCountEl = document.getElementById('applesCount');
      const gridRange = document.getElementById('gridRange');
      const gridLabel = document.getElementById('gridLabel');
      const speedRange = document.getElementById('speedRange');
      const speedLabel = document.getElementById('speedLabel');
      const appleCountRange = document.getElementById('appleCount');

      // Helpers
      function randPos(){
        return {x: Math.floor(Math.random()*grid), y: Math.floor(Math.random()*grid)};
      }

      function placeApples(){
        apples = [];
        const occupied = new Set(snake.map(p => p.x+","+p.y));
        while(apples.length < appleCount){
          const p = randPos();
          const key = p.x+","+p.y;
          if(occupied.has(key)) continue;
          if(apples.some(a=>a.x===p.x && a.y===p.y)) continue;
          apples.push(p);
        }
        applesCountEl.textContent = apples.length;
      }

      function reset(){
        grid = parseInt(gridRange.value,10);
        cellSize = canvas.width / grid;
        snake = [{x: Math.floor(grid/2), y: Math.floor(grid/2)}];
        dir = {x:1,y:0}; nextDir = dir;
        appleCount = parseInt(appleCountRange.value,10);
        baseSpeed = parseInt(speedRange.value,10);
        moveInterval = 1000 / baseSpeed;
        score = 0; running = false; paused = false;
        placeApples();
        updateUI();
        draw();
      }

      function updateUI(){
        scoreEl.textContent = score;
        lenEl.textContent = snake.length;
        applesCountEl.textContent = apples.length;
        gridLabel.textContent = grid;
        speedLabel.textContent = baseSpeed;
      }

      function draw(){
        // background
        ctx.clearRect(0,0,canvas.width,canvas.height);
        // grid subtle
        ctx.fillStyle = '#061025';
        ctx.fillRect(0,0,canvas.width,canvas.height);

        // apples
        for(const a of apples){
          drawCell(a.x,a.y,'#ff4b4b');
          // small shine
          ctx.fillStyle = 'rgba(255,255,255,0.12)';
          ctx.fillRect(a.x*cellSize + cellSize*0.18, a.y*cellSize + cellSize*0.12, cellSize*0.22, cellSize*0.18);
        }

        // snake body
        for(let i=snake.length-1;i>=0;i--){
          const p = snake[i];
          const t = i===0 ? '#ffd166' : (i%2? '#ffd8a6' : '#ffecb8');
          drawCell(p.x,p.y,t);
        }

        // score overlay
        ctx.fillStyle = 'rgba(0,0,0,0.25)';
        ctx.fillRect(6,6,140,34);
        ctx.fillStyle = '#fff';
        ctx.font = '16px Inter, Arial';
        ctx.fillText('Score: '+score,14,28);
      }

      function drawCell(x,y,color){
        const px = x*cellSize, py = y*cellSize;
        const r = Math.max(2, cellSize*0.12);
        // rounded rectangle
        ctx.fillStyle = color;
        roundRect(ctx, px+2, py+2, cellSize-4, cellSize-4, r, true, false);
      }

      function roundRect(ctx, x, y, w, h, r, fill, stroke) {
        if (typeof r === 'undefined') r = 5;
        if (typeof stroke === 'undefined') stroke = true;
        if (typeof r === 'number') r = {tl: r, tr: r, br: r, bl: r};
        ctx.beginPath();
        ctx.moveTo(x + r.tl, y);
        ctx.lineTo(x + w - r.tr, y);
        ctx.quadraticCurveTo(x + w, y, x + w, y + r.tr);
        ctx.lineTo(x + w, y + h - r.br);
        ctx.quadraticCurveTo(x + w, y + h, x + w - r.br, y + h);
        ctx.lineTo(x + r.bl, y + h);
        ctx.quadraticCurveTo(x, y + h, x, y + h - r.bl);
        ctx.lineTo(x, y + r.tl);
        ctx.quadraticCurveTo(x, y, x + r.tl, y);
        ctx.closePath();
        if (fill) ctx.fill();
        if (stroke) ctx.stroke();
      }

      function step(){
        // move head
        const head = {x: snake[0].x + dir.x, y: snake[0].y + dir.y};
        // wrap-around playfield
        if(head.x < 0) head.x = grid-1;
        if(head.y < 0) head.y = grid-1;
        if(head.x >= grid) head.x = 0;
        if(head.y >= grid) head.y = 0;

        // self-collision -> cut tail to simulate damage or end game? We'll end game
        if(snake.some((s,i)=> i>0 && s.x===head.x && s.y===head.y)){
          running = false;
          alert('Game over! Score: '+score);
          return;
        }

        snake.unshift(head);

        // check apples
        let ate = false;
        for(let i = apples.length-1; i>=0; i--){
          const a = apples[i];
          if(a.x === head.x && a.y === head.y){
            ate = true;
            apples.splice(i,1);
            score += 10; // each apple value
            // growth: add extra segments (we simply don't pop tail for X times)
            // we simulate by adding small bonus: push dummy tail elements at end
            for(let g=0; g<2; g++){ // each apple adds 2 extra length
              snake.push({...snake[snake.length-1]});
            }
            break;
          }
        }

        if(!ate){
          // normal move - remove tail
          snake.pop();
        } else {
          // if apples were eaten, respawn new apples to maintain appleCount
          while(apples.length < appleCount){
            // avoid placing on snake
            let tries=0;
            while(tries < 200){
              const p = randPos();
              const key = p.x+","+p.y;
              if(snake.some(s=>s.x===p.x && s.y===p.y)) { tries++; continue; }
              if(apples.some(a=>a.x===p.x && a.y===p.y)) { tries++; continue; }
              apples.push(p); break;
            }
            if(tries>=200) break;
          }
        }

        // subtle dynamic difficulty: every 50 score increase speed up a little
        const extra = Math.floor(score/50);
        moveInterval = 1000 / Math.min(22, baseSpeed + extra);

        updateUI();
      }

      function gameLoop(ts){
        if(!running || paused) { draw(); requestAnimationFrame(gameLoop); return; }
        if(!lastMoveTime) lastMoveTime = ts;
        const elapsed = ts - lastMoveTime;
        if(elapsed >= moveInterval){
          // commit nextDir to dir if not opposite
          if(!(nextDir.x === -dir.x && nextDir.y === -dir.y)) dir = nextDir;
          step();
          lastMoveTime = ts;
        }
        draw();
        requestAnimationFrame(gameLoop);
      }

      // Input
      window.addEventListener('keydown', (e)=>{
        switch(e.key){
          case 'ArrowUp': case 'w': case 'W': nextDir = {x:0,y:-1}; break;
          case 'ArrowDown': case 's': case 'S': nextDir = {x:0,y:1}; break;
          case 'ArrowLeft': case 'a': case 'A': nextDir = {x:-1,y:0}; break;
          case 'ArrowRight': case 'd': case 'D': nextDir = {x:1,y:0}; break;
          case ' ': paused = !paused; break;
        }
      });

      // simple swipe support for mobile
      (function addSwipe(){
        let touchStart = null;
        canvas.addEventListener('touchstart', e=>{ const t = e.touches[0]; touchStart = {x:t.clientX,y:t.clientY}; });
        canvas.addEventListener('touchend', e=>{ if(!touchStart) return; const t = e.changedTouches[0]; const dx = t.clientX - touchStart.x; const dy = t.clientY - touchStart.y; if(Math.abs(dx) > Math.abs(dy)) { if(dx>0) nextDir={x:1,y:0}; else nextDir={x:-1,y:0}; } else { if(dy>0) nextDir={x:0,y:1}; else nextDir={x:0,y:-1}; } touchStart = null; });
      })();

      // UI handlers
      startBtn.addEventListener('click', ()=>{ if(!running){ running=true; paused=false; lastMoveTime=0; requestAnimationFrame(gameLoop);} });
      pauseBtn.addEventListener('click', ()=>{ paused = !paused; });
      resetBtn.addEventListener('click', ()=>{ reset(); });

      gridRange.addEventListener('input', ()=>{ gridLabel.textContent = gridRange.value; });
      speedRange.addEventListener('input', ()=>{ speedLabel.textContent = speedRange.value; });
      appleCountRange.addEventListener('input', ()=>{ applesCountEl.textContent = appleCountRange.value; });

      // commit changes on release to avoid mid-game weirdness
      gridRange.addEventListener('change', ()=>{ reset(); });
      speedRange.addEventListener('change', ()=>{ baseSpeed = parseInt(speedRange.value,10); moveInterval = 1000 / baseSpeed; updateUI(); });
      appleCountRange.addEventListener('change', ()=>{ appleCount = parseInt(appleCountRange.value,10); placeApples(); updateUI(); });

      // initial
      placeApples(); updateUI(); draw();

    })();
  </script>
</body>
</html>
